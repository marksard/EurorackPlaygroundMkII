/*!
 * Oscillator class
 * Copyright 2023 marksard
 * This software is released under the MIT license.
 * see https://opensource.org/licenses/MIT
 */

#pragma once
#include <Arduino.h>

const uint16_t decayCurveSize = 1024;
const uint16_t decayCurve[1024] = {
    1024, 1019, 1015, 1011, 1007, 1003, 999, 995, 991, 987, 984, 980, 976, 972, 968, 964,
    960, 956, 953, 949, 945, 941, 938, 934, 930, 926, 923, 919, 915, 912, 908, 904,
    901, 897, 894, 890, 887, 883, 879, 876, 872, 869, 866, 862, 859, 855, 852, 848,
    845, 842, 838, 835, 832, 828, 825, 822, 818, 815, 812, 809, 805, 802, 799, 796,
    793, 789, 786, 783, 780, 777, 774, 771, 768, 764, 761, 758, 755, 752, 749, 746,
    743, 740, 737, 734, 731, 729, 726, 723, 720, 717, 714, 711, 708, 705, 703, 700,
    697, 694, 691, 689, 686, 683, 680, 678, 675, 672, 670, 667, 664, 662, 659, 656,
    654, 651, 648, 646, 643, 641, 638, 635, 633, 630, 628, 625, 623, 620, 618, 615,
    613, 610, 608, 605, 603, 600, 598, 596, 593, 591, 588, 586, 584, 581, 579, 577,
    574, 572, 570, 567, 565, 563, 561, 558, 556, 554, 552, 549, 547, 545, 543, 541,
    538, 536, 534, 532, 530, 528, 525, 523, 521, 519, 517, 515, 513, 511, 509, 507,
    504, 502, 500, 498, 496, 494, 492, 490, 488, 486, 484, 482, 480, 478, 477, 475,
    473, 471, 469, 467, 465, 463, 461, 459, 457, 456, 454, 452, 450, 448, 446, 445,
    443, 441, 439, 437, 436, 434, 432, 430, 429, 427, 425, 423, 422, 420, 418, 416,
    415, 413, 411, 410, 408, 406, 405, 403, 401, 400, 398, 396, 395, 393, 392, 390,
    388, 387, 385, 384, 382, 380, 379, 377, 376, 374, 373, 371, 370, 368, 367, 365,
    364, 362, 361, 359, 358, 356, 355, 353, 352, 350, 349, 347, 346, 345, 343, 342,
    340, 339, 337, 336, 335, 333, 332, 331, 329, 328, 326, 325, 324, 322, 321, 320,
    318, 317, 316, 314, 313, 312, 311, 309, 308, 307, 305, 304, 303, 302, 300, 299,
    298, 297, 295, 294, 293, 292, 291, 289, 288, 287, 286, 285, 283, 282, 281, 280,
    279, 277, 276, 275, 274, 273, 272, 271, 269, 268, 267, 266, 265, 264, 263, 262,
    260, 259, 258, 257, 256, 255, 254, 253, 252, 251, 250, 249, 248, 247, 246, 244,
    243, 242, 241, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231, 230, 229, 228,
    227, 227, 226, 225, 224, 223, 222, 221, 220, 219, 218, 217, 216, 215, 214, 213,
    212, 212, 211, 210, 209, 208, 207, 206, 205, 204, 204, 203, 202, 201, 200, 199,
    198, 197, 197, 196, 195, 194, 193, 192, 192, 191, 190, 189, 188, 187, 187, 186,
    185, 184, 183, 183, 182, 181, 180, 180, 179, 178, 177, 176, 176, 175, 174, 173,
    173, 172, 171, 170, 170, 169, 168, 167, 167, 166, 165, 164, 164, 163, 162, 162,
    161, 160, 160, 159, 158, 157, 157, 156, 155, 155, 154, 153, 153, 152, 151, 151,
    150, 149, 149, 148, 147, 147, 146, 145, 145, 144, 143, 143, 142, 141, 141, 140,
    140, 139, 138, 138, 137, 137, 136, 135, 135, 134, 133, 133, 132, 132, 131, 130,
    130, 129, 129, 128, 128, 127, 126, 126, 125, 125, 124, 124, 123, 122, 122, 121,
    121, 120, 120, 119, 119, 118, 118, 117, 116, 116, 115, 115, 114, 114, 113, 113,
    112, 112, 111, 111, 110, 110, 109, 109, 108, 108, 107, 107, 106, 106, 105, 105,
    104, 104, 103, 103, 102, 102, 101, 101, 100, 100, 99, 99, 98, 98, 98, 97,
    97, 96, 96, 95, 95, 94, 94, 93, 93, 93, 92, 92, 91, 91, 90, 90,
    90, 89, 89, 88, 88, 87, 87, 87, 86, 86, 85, 85, 84, 84, 84, 83,
    83, 82, 82, 82, 81, 81, 80, 80, 80, 79, 79, 79, 78, 78, 77, 77,
    77, 76, 76, 75, 75, 75, 74, 74, 74, 73, 73, 73, 72, 72, 71, 71,
    71, 70, 70, 70, 69, 69, 69, 68, 68, 68, 67, 67, 67, 66, 66, 66,
    65, 65, 65, 64, 64, 64, 63, 63, 63, 62, 62, 62, 61, 61, 61, 60,
    60, 60, 59, 59, 59, 58, 58, 58, 58, 57, 57, 57, 56, 56, 56, 55,
    55, 55, 55, 54, 54, 54, 53, 53, 53, 53, 52, 52, 52, 51, 51, 51,
    51, 50, 50, 50, 49, 49, 49, 49, 48, 48, 48, 48, 47, 47, 47, 47,
    46, 46, 46, 45, 45, 45, 45, 44, 44, 44, 44, 43, 43, 43, 43, 42,
    42, 42, 42, 41, 41, 41, 41, 41, 40, 40, 40, 40, 39, 39, 39, 39,
    38, 38, 38, 38, 37, 37, 37, 37, 37, 36, 36, 36, 36, 35, 35, 35,
    35, 35, 34, 34, 34, 34, 34, 33, 33, 33, 33, 33, 32, 32, 32, 32,
    31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 29, 29, 29, 29, 29, 29,
    28, 28, 28, 28, 28, 27, 27, 27, 27, 27, 26, 26, 26, 26, 26, 26,
    25, 25, 25, 25, 25, 24, 24, 24, 24, 24, 24, 23, 23, 23, 23, 23,
    23, 22, 22, 22, 22, 22, 22, 21, 21, 21, 21, 21, 21, 20, 20, 20,
    20, 20, 20, 20, 19, 19, 19, 19, 19, 19, 18, 18, 18, 18, 18, 18,
    18, 17, 17, 17, 17, 17, 17, 17, 16, 16, 16, 16, 16, 16, 16, 15,
    15, 15, 15, 15, 15, 15, 14, 14, 14, 14, 14, 14, 14, 13, 13, 13,
    13, 13, 13, 13, 13, 12, 12, 12, 12, 12, 12, 12, 12, 11, 11, 11,
    11, 11, 11, 11, 11, 10, 10, 10, 10, 10, 10, 10, 10, 9, 9, 9,
    9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

template <typename vs = int16_t>
class SingleShotWave
{
public:
    SingleShotWave(const vs wave[], uint32_t waveLength)
    {
        _pWave = wave;
        _waveLength = waveLength;
    }

    void init()
    {
        _start = false;
        _waveIndex = 0.0;
        _speed = 1.0;
        _bias = 1024;
        _decayIndex = 0.0;
        _decayValue = 0;
        _lastEdge = 0;
        // _lastValue = _bias;
    }

    uint16_t updateWave()
    {
        if (!_start)
            return _bias;
        int16_t value = _pWave[(int)_waveIndex];
        _waveIndex += _speed;
        if (_waveIndex >= _waveLength)
        {
            _start = false;
            _waveIndex = 0.0;
            _decayIndex = 0.0;
            // _lastValue = _bias;
            return _bias;
        }

        value = (uint16_t)((((int32_t)value * _decayValue) >> 10) + _bias);
        // simplest linear interpolation
        // value = (_lastValue + value) >> 1;
        // _lastValue = value;
        return value;
    }

    void play(int8_t edge)
    {
        if (_lastEdge == 0 && edge != 0)
        {
            _start = true;
            _waveIndex = 0.0;
            _decayIndex = 0.0;
        }
        _lastEdge = edge;
    }

    void setSpeed(float value) { _speed = value; }

    void updateDecay(float value)
    {
        float decay = (1.0 - value);
        _decayValue = decayCurve[(int)_decayIndex];
        _decayIndex += decay;
        if (_decayIndex >= decayCurveSize)
        {
            _start = false;
        }
    }

    void setBias(vs bias) { _bias = bias; }

private:
    const vs *_pWave;
    uint32_t _waveLength;
    bool _start;
    float _waveIndex;
    float _speed;
    vs _bias;
    // vs _lastValue;
    float _decayIndex;
    int16_t _decayValue;
    int8_t _lastEdge;
};
